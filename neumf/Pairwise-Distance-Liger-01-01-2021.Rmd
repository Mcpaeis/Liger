---
title: "Pairwise-Distance-Liger-01-01-2021"
author: "Sixtus Dakurah"
date: "1/1/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
```

```{r}
pbmc_10X_c <- read.table("/Users/sixtusdakurah/Desktop/Liger/data/pbmc_10X.txt")
pbmc_SqW_c <- read.table("/Users/sixtusdakurah/Desktop/liger/data/pbmc_SeqWell.txt")
pbmc_10X_Cells_c <- names(pbmc_10X_c)
pbmc_SqW_Cells_c <- names(pbmc_SqW_c)
```

```{r}
pbmc_10X <- read.csv("/Users/sixtusdakurah/Desktop/Liger/data/H2-Liger.csv")
head(pbmc_10X)
```


```{r}
library(data.table)
# read in the data
pbmc_10X <- read.csv("/Users/sixtusdakurah/Desktop/Liger/data/H2-Liger.csv")[, -1]
#pbmc_10X <- pbmc_10X[, -dim(pbmc_10X)[2]]
#colnames(pbmc_10X) <- pbmc_10X_Cells_c
rownames(pbmc_10X) <- pbmc_10X_Cells_c
head(pbmc_10X)
```



```{r}
pbmc_SqW <- read.csv("/Users/sixtusdakurah/Desktop/liger/data/H1-Liger.csv")[, -1]
#pbmc_SqW <- pbmc_SqW[, -dim(pbmc_SqW)[2]]
rownames(pbmc_SqW) <- pbmc_SqW_Cells_c
head(pbmc_SqW)
```


```{r}
#pbmc_10X[pbmc_10X < 0] <- 0
#pbmc_SqW[pbmc_SqW < 0] <- 0
#(tail(pbmc_10X))[, 2634:2638]
head(pbmc_SqW)
dim(pbmc_10X)
dim(pbmc_SqW)
```

```{r}
# get the cells from the two groups
pbmc_10X_Cells <- names(pbmc_10X)
print(length(unique(pbmc_10X_Cells)))
pbmc_SqW_Cells <- names(pbmc_SqW)
print(length(unique(pbmc_SqW_Cells)))
```



```{r}
# load the cluster data
original_clusters <- read.csv("/Users/sixtusdakurah/desktop/liger/clusters.csv") #head(original_clusters)
head(original_clusters)
dim(original_clusters)
```

```{r}
# how many unique clusters do we have
print(length(unique(original_clusters$x))) # 14 unique clusters
# how many cells from 10x are in the cluster group
#print(length(intersect(pbmc_10X_Cells, original_clusters$X)))
# how many cells from sqw are in the cluster group
#print(length(intersect(pbmc_SqW_Cells, original_clusters$X)))
```

### Compute the triplet loss

```{r}
computeError <- function(a, p, n) {
  pos_loss = sum( (a-p)^2 )
  neg_loss = sum( (a - n)^2 )
  val  =  pos_loss - neg_loss
  return(c(max(val, 0), pos_loss, neg_loss))
}

computeTripletLoss <- function(embedding, clusters){
  
  ## First have to regroup the embedding cells and clusters
  ## Monocytes (white blood cells) is exclusive to only 10x expressions
  cell_groups <- list(
    c("B cells", "Bcell"),  
    c("Megakaryocytes", "Myeloid"), 
    c("CD4", "CD4 T cells"), 
    c("CD8", "CD8 T cells"), 
    c("DC", "Dentritic cells"), 
    c("NK", "NK cells"))
  
  clusters$group <- clusters$x
  for(grp in cell_groups){
    clusters[clusters$x %in% grp, "group"] <- grp[1] 
  }
  
  #cellGroups <- unique(clusters$group)
  
  # transpose the embedding
  #embedding <- as.data.frame(t(embedding)) no transpose needed
  #print(head(embedding))
  
  #for(cellG in cellGroups){
    
    #anchor_pos <- clusters %>% filter(group==cellG)
    #hard_neg <- clusters %>% filter(group!=cellG)
    #hard_neg_cells <- hard_neg$X
    
    #cells <- embedding$X
    cells <- rownames(embedding)
    
    # this loss variable should be inside
    loss = data.frame("cell" = cells, "error" = rep(10000, length(cells)), "pos_error" = rep(10000, length(cells)), "neg_error" = rep(10000, length(cells)))
    #print(loss)
    loss_count = 1
    
    for (cell in cells){
      # Get the cell group
      cellG <- (clusters[clusters$X==cell, ])$group # this will be a single observation because the cells are unique in the clusters
      # Now construct the a, p, and n
      anchor_pos <- clusters %>% filter(group==cellG)
      hard_neg <- clusters %>% filter(group!=cellG)
      hard_neg_cells <- hard_neg$X
      # pick a hard positive
      hard_positive <- (sample_n(anchor_pos[anchor_pos$X!=cell, ], 1))$X
      #print(hard_positive)
      # pick a hard negative
      neg_found = 0
      hard_neg_pool <- rownames(embedding[rownames(embedding)!=cell, ])
      for (hnp in hard_neg_pool){
        if (hnp %in% hard_neg_cells){
            hard_negative <- hnp
            neg_found = 2
            break
          }
      }
      #while (neg_found < 1) {
      #  hard_negative <- sample(rownames(embedding[rownames(embedding)!=cell, ]), 1)
      # if (hard_negative %in% hard_neg_cells) {neg_found = 2}
      #}
      
      if(neg_found==2){
        # now get the vectors associated with these cells
        anchor_vec <- embedding[rownames(embedding)==cell, ]
        #print(cell)
        pos_vec <- embedding[rownames(embedding)==hard_positive, ]
        #print(hard_positive)
        neg_vec <- embedding[rownames(embedding)==hard_negative, ]
        #print(hard_negative)
        #print((anchor_vec)); print((pos_vec)); print((neg_vec))
        
        # compute the square loss
        error <- computeError(anchor_vec, pos_vec, neg_vec) 
        
        loss[loss_count, "error"] <- error[1]
        loss[loss_count, "pos_error"] <- error[2]
        loss[loss_count, "neg_error"] <- error[3]
        loss_count = loss_count + 1
      } # otherwise we don't have a hard negative for that cell
    }
  
    #print(paste("loss:", loss))
    return(loss)
  #}
}
```

```{r}
library(tidyverse)
# merge the dataset
pbmc_10XSqWMergedTPL_Embedded_liger <- rbind(pbmc_10X, pbmc_SqW)
write.csv(pbmc_10XSqWMergedTPL_Embedded_liger, "/Users/sixtusdakurah/Desktop/liger/data/liger_merged_embeddings.csv")
#head(pbmc_10XSqWMergedTPL_Embedded)
tpl_df_embedded_liger <- computeTripletLoss(pbmc_10XSqWMergedTPL_Embedded_liger, original_clusters)
```

```{r}
head(tpl_df_embedded_liger)
```


```{r}
write.csv(tpl_df_embedded_liger, "/Users/sixtusdakurah/Desktop/liger/data/tpl_embedded_liger.csv")
```


```{r}
ggplot(data = tpl_df_embedded_liger, mapping = aes(x = cell, y = error)) + geom_point() + theme(axis.text.x=element_blank(),axis.ticks.x=element_blank())
```


```{r}
#tpl_df_embedded[tpl_df_embedded$error==10000, ]
write.csv(tpl_df_embedded_liger, "/Users/sixtusdakurah/Desktop/liger/data/tpl_embedded_liger.csv")
```

### What we can't do: compute the pairwise distances between cells across datasets in the same cluster group. This is because, for any given pair, they could have different level of gene expressions if they come from different data sets.


### What we can do: compute the pairwise distances between cells in the same cluster group for each dataset.


### Pairwise distances for cells in 10x

```{r}
# first scale the dataframe to columns to begin with
# scaling is by dividing the column values by the rmse for the particular column
pbmc_10X_scale <- pbmc_10X#data.frame(scale(pbmc_10X, center = FALSE)) # we need positive expressions
pbmc_SqW_scale <- pbmc_SqW#data.frame(scale(pbmc_SqW, center = FALSE)) # we need positive expressions
```


```{r}
pairwiseClusterDistance <- function(data, clusters){
  # create an empty vector to store the average pairwise distances
  uniq.clusters <- unique(clusters$x)
  K <- length(uniq.clusters)
  average_pairwise <- c(rep(NA, length(uniq.clusters)))
  pair_wise_list  <- list()
  # for each unique cluster, compute the average pairwise distance
  for (k in 1:K){
    # select all cells that belongs to this cluster
    belongs <- clusters[clusters$x==uniq.clusters[k], ]
    # then select all cells from the expression matrix that are in belongs
    data_cells <- names(data)
    relevant_cells <- intersect(data_cells, belongs$X)
    #print(length(relevant_cells))
    # now select columns based on relevant cells
    sub_data <- data[, relevant_cells]
    # conver to matrix and transpose for use in the distance function
    sub_matrix = t(as.matrix(sub_data))
    # add the avergae distance to the vector
    num_pairwsie = choose(length(relevant_cells), 2)
    pair_wise_dist  = dist(sub_matrix)
    pair_wise_list[[length(pair_wise_list)+1]]  <- list(as.vector(pair_wise_dist))
    average_pairwise[k]  = sum(pair_wise_dist)/num_pairwsie
  }
  return(list(average_pairwise, pair_wise_list))
}
```



```{r}
pairwise_10x = pairwiseClusterDistance(pbmc_10X_scale, original_clusters)
pairwise_SqW = pairwiseClusterDistance(pbmc_SqW_scale, original_clusters)
```


```{r}
pairwise_df = data.frame("clusters" = unique(original_clusters$x))
pairwise_df$pbmc_10X = pairwise_10x[[1]]
pairwise_df$pbmc_SqW = pairwise_SqW[[1]]
pairwise_df
```

```{r}
# convert the list into a long df
uniq.clusters <- unique(original_clusters$x)
pair_wise_list_10X <- pairwise_10x[[2]]
pair_wise_list_SqW <- pairwise_SqW[[2]]

df_10XSQW = data.frame("cluster" = 'cluster', "distance" = 0, "dataset" = 'd')

K = length(uniq.clusters)

for(k in 1:K){
  ls1 = pair_wise_list_SqW[[k]][[1]]
  ls2 = pair_wise_list_10X[[k]][[1]]
  
  if (length(ls1)!=0){
    ds <- rep("SqW", length(ls1))
    cluster <- rep(uniq.clusters[k], length(ls1))
    df_sqw = data.frame("cluster" = cluster, "distance" = ls1, "dataset" = ds)
    
    df_10XSQW = rbind(df_10XSQW, df_sqw)
  }
  
  if (length(ls2)!=0){
    ds <- rep("10X", length(ls2))
    cluster <- rep(uniq.clusters[k], length(ls2))
    df_10x = data.frame("cluster" = cluster, "distance" = ls2, "dataset" = ds)
    df_10XSQW = rbind(df_10XSQW, df_10x)
  }
}
```


### Repeat the same for variable genes -- will not change anything

```{r}
varG <- read.csv("/Users/sixtusdakurah/desktop/liger/data/varG.csv")
var_genes <- varG$x
pbmc_10X_scale_var <- pbmc_10X_scale#[rownames(pbmc_10X_scale) %in% var_genes, ]
pbmc_SqW_scale_var <- pbmc_SqW_scale#[rownames(pbmc_SqW_scale) %in% var_genes, ]
```

```{r}
# write to excel
#write.csv(pbmc_10X_scale_var, file = "pbmc_10X_var.csv")
#write.csv(pbmc_SqW_scale_var, file = "pbmc_SqW_var.csv")
```


```{r}
pairwise_10x_var = pairwiseClusterDistance(pbmc_10X_scale_var, original_clusters)
pairwise_SqW_var = pairwiseClusterDistance(pbmc_SqW_scale_var, original_clusters)
```


```{r}
pairwise_df_var = data.frame("clusters" = unique(original_clusters$x))
pairwise_df_var$pbmc_10X = pairwise_10x_var[[1]]
pairwise_df_var$pbmc_SqW = pairwise_SqW_var[[1]]
pairwise_df_var
```

```{r}
uniq.clusters <- unique(original_clusters$x)
pair_wise_list_10X_var <- pairwise_10x_var[[2]]
pair_wise_list_SqW_var <- pairwise_SqW_var[[2]]

df_10XSQW_var = data.frame("cluster" = 'cluster', "distance" = 0, "dataset" = 'd')

K = length(uniq.clusters)

for(k in 1:K){
  ls1_var = pair_wise_list_SqW_var[[k]][[1]]
  ls2_var = pair_wise_list_10X_var[[k]][[1]]
  
  if (length(ls1_var)!=0){
    ds_var <- rep("SqW", length(ls1_var))
    cluster_var <- rep(uniq.clusters[k], length(ls1_var))
    df_sqw_var = data.frame("cluster" = cluster_var, "distance" = ls1_var, "dataset" = ds_var)
    
    df_10XSQW_var = rbind(df_10XSQW_var, df_sqw_var)
  }
  
  if (length(ls2_var)!=0){
    ds_var <- rep("10X", length(ls2_var))
    cluster_var <- rep(uniq.clusters[k], length(ls2_var))
    df_10x_var = data.frame("cluster" = cluster_var, "distance" = ls2_var, "dataset" = ds_var)
    df_10XSQW_var = rbind(df_10XSQW_var, df_10x_var)
  }
}
```


### Now make the boxplots

```{r}
head(df_10XSQW)
```


```{r}
library(ggplot2)
ggplot(data = df_10XSQW[-1, ]) + 
  geom_boxplot(mapping = aes(x = cluster, y = distance, color = dataset), outlier.size = 0) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle("Embedded-All Genes")
```

```{r}
ggplot(data = df_10XSQW_var[-1, ]) + 
  geom_boxplot(mapping = aes(x = cluster, y = distance, color = dataset), outlier.size = 0) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle("Embedded-Variable Genes")
```


### Format the cell group names

```{r}
## Monocyets (white blood cells) is exclusive to only 10x expressions
cell_groups <- list(
  c("B cells", "Bcell"),  
  c("Megakaryocytes", "Myeloid"), 
  c("CD4", "CD4 T cells"), 
  c("CD8", "CD8 T cells"), 
  c("DC", "Dentritic cells"), 
  c("NK", "NK cells"))

original_clusters$group <- original_clusters$x
for(grp in cell_groups){
 original_clusters[original_clusters$x %in% grp, "group"] <- grp[1] 
}
tail(original_clusters)
```

```{r}
# Format the cells for SQwell expressions
extractCell <- function(x){
  substring(x, 0, regexpr("_", x) - 1)
}

pbmc_SqW_Cells_format <- lapply(pbmc_SqW_Cells, extractCell)
```

```{r}
# merge the dataset
#merged_data <- cbind(pbmc_10X_scale_var, pbmc_SqW_scale_var)
merged_data <- cbind(pbmc_10X_scale_var, pbmc_SqW_scale_var)

dim(merged_data)
tail(merged_data[, 6329:6332])
```

```{r}
# add the labels to the cells for triplet loss training
labels_df <- rep("", dim(merged_data)[2])
names(labels_df) <- names(merged_data)
cellCount  = dim(merged_data)[2]

merged_labels <- rbind(merged_data, labels_df)
lastIndex = dim(merged_labels)[1]
tail(merged_labels[, 6329:6332])
merged_names <- names(merged_labels)
```

```{r}
for (c in 1:cellCount){
  cell  = merged_names[c]
  # select the label from the clusters
  lab = (original_clusters[original_clusters$X==cell, ])$group
  if(length(lab) >= 1){
    if(is.na(cell)){
      print(cell)
      print(c)
    }else{
    merged_labels[lastIndex, cell] <- lab
    }
  }
  #print(lab)
  # assign the lable
}
```

```{r}
#rownames(merged_labels)[rownames(merged_labels) == "2815"] <- "Labels"
#write.csv(merged_labels, file = "merged_with_labels.csv")
#tail(merged_labels[, 6331:6332])
```



```{r}
pairwiseClusterDistanceMerged <- function(data, clusters){
  # create an empty vector to store the average pairwise distances
  uniq.clusters <- unique(clusters$group)
  K <- length(uniq.clusters)
  average_pairwise <- c(rep(NA, length(uniq.clusters)))
  pair_wise_list  <- list()
  # for each unique cluster, compute the average pairwise distance
  for (k in 1:K){
    # select all cells that belongs to this cluster
    belongs <- clusters[clusters$group==uniq.clusters[k], ]
    # then select all cells from the expression matrix that are in belongs
    data_cells <- names(data)
    relevant_cells <- intersect(data_cells, belongs$X)
    # now select columns based on relevant cells
    sub_data <- data[, relevant_cells]
    # convert to matrix and transpose for use in the distance function
    sub_matrix = t(as.matrix(sub_data))
    # add the avergae distance to the vector
    num_pairwsie = choose(length(relevant_cells), 2)
    pair_wise_dist  = dist(sub_matrix)
    pair_wise_list[[length(pair_wise_list)+1]]  <- list(as.vector(pair_wise_dist))
    average_pairwise[k]  = sum(pair_wise_dist)/num_pairwsie
  }
  return(list(average_pairwise, pair_wise_list))
}
```

```{r}
pairwise_10xSqW = pairwiseClusterDistanceMerged(merged_data, original_clusters)
```


```{r}
pairwise_df_var_merged = data.frame("clusters" = unique(original_clusters$group))
pairwise_df_var_merged$pbmc_10Xpbmc_SqW = pairwise_10xSqW[[1]]
pairwise_df_var_merged
```

```{r}
uniq.clusters <- unique(original_clusters$group)
pair_wise_list_10XSqW_var <- pairwise_10xSqW[[2]]

df_10XSQW_var_merged = data.frame("cluster" = 'cluster', "distance" = 0)

K = length(uniq.clusters)

for(k in 1:K){
  ls_var = pair_wise_list_10XSqW_var[[k]][[1]]
  
  if (length(ls_var)!=0){
    cluster_var_10xsqwl <- rep(uniq.clusters[k], length(ls_var))
    df_10xsqw_var_merged = data.frame("cluster" = cluster_var_10xsqwl, "distance" = ls_var)
    
    df_10XSQW_var_merged = rbind(df_10XSQW_var_merged, df_10xsqw_var_merged)
  }
}
```

```{r}
ggplot(data = df_10XSQW_var_merged[-1, ]) + 
  geom_boxplot(mapping = aes(x = cluster, y = distance), outlier.size = 0) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle("Liger-Variable Genes")
```


### Now make a combined boxplot

```{r}
df_10XSQW_var_merged$dataset <- rep("merged", dim(df_10XSQW_var_merged)[1])
all_pairwise <- rbind(df_10XSQW_var_merged, df_10XSQW_var[-1, ])
tail(all_pairwise)
```

```{r}
ggplot(data = all_pairwise[-1, ]) + 
  geom_boxplot(mapping = aes(x = cluster, y = distance, color = dataset), outlier.size = 0) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ggtitle("Liger-Variable Genes")
```











