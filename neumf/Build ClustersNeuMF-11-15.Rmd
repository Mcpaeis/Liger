---
title: "Build Clusters"
author: "Sixtus Dakurah"
date: "5/15/2020"
output: pdf_document
---

```{r setup, include=FALSE}
rm(list = ls()) # clear environment
knitr::opts_chunk$set(echo = TRUE)
# load packages
library(liger)
library(Matrix)
library(patchwork)
```


## Load and Process Data

```{r load-data}
RDS_from_web <- function(url) {

  tempFile_location<- tempfile()
  download.file(url, tempFile_location)
  b <- readRDS(tempFile_location)
  file.remove(tempFile_location)
  b
}

# load data: PBMC - Peripheral Blood Mononuclear Cell, both control and stimulated set
ctrl_dge <- RDS_from_web("https://sixtusdakurah.com/projects/liger/ctrl_dge.rds") # original PBMC data
stim_dge <- RDS_from_web("https://sixtusdakurah.com/projects/liger/stim_dge.rds") # original PBMC data

ctrl_dge_1 <- RDS_from_web("https://sixtusdakurah.com/projects/liger/ctrl_dge_1.rds") # dense representation from NeuMF
stim_dge_1 <- RDS_from_web("https://sixtusdakurah.com/projects/liger/stim_dge_1.rds") # dense representation from NeuMF
```


```{r convert-to-zero}
ctrl_dge_ = ctrl_dge_1
stim_dge_ = stim_dge_1

# option 1 convert negative occurences to 0
ctrl_dge_[ctrl_dge_ < 0] = 0
stim_dge_[stim_dge_ < 0] = 0

# option 2
# ctrl_dge_[sapply(ctrl_dge_, is.double)] <- ctrl_dge_[sapply(ctrl_dge_, is.double)] + 0.5
# stim_dge_[sapply(stim_dge_, is.double)] <- stim_dge_[sapply(stim_dge_, is.double)] + 0.5

# option 3 -- can combine with option 1 or option 2
# ctrl_dge_[sapply(ctrl_dge_, is.double)] <-lapply(ctrl_dge_[sapply(ctrl_dge_, is.double)], as.integer)
# stim_dge_[sapply(stim_dge_, is.double)] <-lapply(stim_dge_[sapply(stim_dge_, is.double)], as.integer)

#head(ctrl_dge_)
#head(stim_dge_)
#head(ctrl_dge)
#head(stim_dge)
```




```{r reassign}
ctrl_dge1 <- ctrl_dge#[1:sub.set, ]#1:(sub.set+1)]
stim_dge1 <- stim_dge#[1:sub.set, ]#1:(sub.set+1)]
ctrl_dge2 <- ctrl_dge1[, -1] # remove the gene index
rownames(ctrl_dge2) <-  ctrl_dge1$X # assign the gene names as row names
stim_dge2 <- stim_dge1[, -1] # remove the gene index
rownames(stim_dge2) <- stim_dge1$X # assign the gene names as row names
head(ctrl_dge2)
head(stim_dge2)


ctrl_dge1_ <- ctrl_dge_[, -1] # remove the gene index
colnames(ctrl_dge1_) <- colnames(ctrl_dge1)[-1] # assign the cell names from the original expression
rownames(ctrl_dge1_) <- ctrl_dge1$X # assign the gene names from the original expression

stim_dge1_ <- stim_dge_[, -1] # remove the gene index
colnames(stim_dge1_) <- colnames(stim_dge1)[-1] # assign the cell names from the original expression
rownames(stim_dge1_) <- stim_dge1$X # assign the gene names from the original expression
head(ctrl_dge1_)
head(stim_dge1_)
```

```{r check-dims}
dim(ctrl_dge2)
dim(stim_dge2)
ctrl_dge3 = (as.matrix(ctrl_dge2))
stim_dge3 = (as.matrix(stim_dge2))

dim(ctrl_dge1_)
dim(stim_dge1_)
ctrl_dge2_ = (as.matrix(ctrl_dge1_))
stim_dge2_ = (as.matrix(stim_dge1_))
```


```{r gabbage-collection}
# gabbage collecction
rm(ctrl_dge); rm(ctrl_dge_); rm(ctrl_dge2); rm(ctrl_dge1_); rm(stim_dge); rm(stim_dge_); rm(stim_dge2); rm(stim_dge1_)
gc()
```


## Create Liger Object and Select Genes

```{r create-liger-objects}
ifnb_liger <- createLiger(list(ctrl = ctrl_dge3, stim = stim_dge3))
ifnb_liger_ <- createLiger(list(ctrl = ctrl_dge2_, stim = stim_dge2_))
```


## Normalize and scale

```{r normalize-scale}
# normalize and scale
ifnb_liger <- normalize(ifnb_liger)
ifnb_liger <- selectGenes(ifnb_liger, do.plot = T, var.thresh = 0.001)
ifnb_liger <- scaleNotCenter(ifnb_liger)

ifnb_liger_ <- normalize(ifnb_liger_)
ifnb_liger_ <- selectGenes(ifnb_liger_, do.plot = T, alpha.thresh = 0.001)
ifnb_liger_ <- scaleNotCenter(ifnb_liger_)
```

## Perform Matrix Factorization


```{r matrix-factorization}
# joint factorization
ifnb_liger <- optimizeALS(ifnb_liger, k = 20)
ifnb_liger_ <- optimizeALS(ifnb_liger_, k = 20)
```


## Normalize and Align Data

```{r warning=FALSE}
# quatile normalize
ifnb_liger <- quantile_norm(ifnb_liger)
ifnb_liger <- louvainCluster(ifnb_liger, resolution = 0.25)

ifnb_liger_ <- quantile_norm(ifnb_liger_)
ifnb_liger_ <- louvainCluster(ifnb_liger_, resolution = 0.25)
```


## Check Expressions Agreement
### This measure how much the factorization and alignment distorts the geometry of the original datsets.

#### 1. Perform dimensionality reduction on the factorized datasets.
#### 2. Measure similarity (Jaccard index) between k-nn for each cell in original datasets, and the aligned datasets.
#### 3. The final metric is obtained by averaging across all cells.

### The greater the agreement, the less distortion in the geometry there is.

### Usually,any agreement higher than 0.2 or 0.3 indicates very little or non-existent distortion in geometry.

```{r}
print(paste("Agreement for Original Expressions: ", round(calcAgreement(ifnb_liger, ndims = 20, k = 20)*100, 2), "%", sep=''))
print(paste("Agreement for NeuMF Expressions: ", round(calcAgreement(ifnb_liger_, ndims = 20, k = 20)*100, 2), "%", sep=''))
```


### There is no apparent distortion in the geometry of the expressions matrix obtained via NeuMF. Same for the original expressions.

### On the otherhand, the original expression matrix shows significant distortion in it's geometry after factorization --- disreegard -old conclusion for 3KG3KC

## Visualize Alignments & Clusters

```{r}
# visualizations
ifnb_liger <- runUMAP(ifnb_liger, distance = 'euclidean', n_neighbors = 10, min_dist = 0.1)
all.plots <- plotByDatasetAndCluster(ifnb_liger, axis.labels = c('UMAP 1', 'UMAP 2'), return.plots = T)
all.plots[[1]] + all.plots[[2]]
```



```{r}
# visualizations
ifnb_liger_ <- runUMAP(ifnb_liger_, distance = 'euclidean', n_neighbors = 10, min_dist = 0.1)

all.plots <- plotByDatasetAndCluster(ifnb_liger_, axis.labels = c('UMAP 1', 'UMAP 2'), return.plots = T)

all.plots[[1]] + all.plots[[2]]
```

## Obviously original expression is better integrated.

## Compute Alignments

### This quantifies how well-aligned the two datasets are.

#### 1. Downsample all datasets to have as many cells as the smallets one.

#### 2. Construct a nn graph and calculate for each cell how many of its neighbors are from the same dataset.

#### 3. Average across all cells and normalize to be between 0 and 1.

### This should be high when genes share common cell types.

### (It turns out alignment can exceed 1. But I couldn't find a practical reason for such).


```{r}
print(paste("Alignment for Original Expressions: ", round(calcAlignment(ifnb_liger)*100, 2), "%", sep=''))
print(paste("Alignment for NeuMF Expressoins: ", round(calcAlignment(ifnb_liger_)*100, 2), "%", sep=''))
```


```{r}
library(tidyr)
df1 <- data.frame(ifnb_liger@clusters)
df2 <- data.frame(ifnb_liger_@clusters)


df1$cell <- rownames(df1)
df2$cell <- rownames(df2)

splitFunc <- function(str){
  l1 <- substr(x, 4)
  
}

#df1$cell <- unlist(lapply(df1$cell, splitFunc))
#df2$cell <- unlist(lapply(df2$cell, splitFunc))

df1 <- df1 %>% tidyr::separate(cell, sep=c(4), into=c("a1","a2")) %>%separate(a2, sep=c(14), into=c("a2","a3"))
df2 <- df2 %>% tidyr::separate(cell, sep=c(4), into=c("a1","a2")) %>%separate(a2, sep=c(14), into=c("a2","a3"))
#df2 %>% separate(cell, sep=c(4, "."), into=c("a1","a2", "a3"))
head(df1)
```

```{r}
dat1 <- (df1[order(df1$a2), ])[, c(1, 3)]
rownames(dat1) <- NULL
dat2 <- (df2[order(df2$a2), ])[, c(1, 3)]
rownames(dat2) <- NULL
head(dat2)
```


```{r}
(table(dat1))[1:13, 1:7]
```


```{r}
clusters <- readRDS("pbmc_alignment/tenx_seqwell_clusters.RDS")
write.csv(clusters, file = "clusters.csv")
```

```{r}
l <- read.csv("clusters.csv")
head(l)
```


```{r}
tn <- 0
tp <- 0
fn <- 0 
fp <- 0

for (i in 1:nrow(dat2)){
  clus1 = dat2$ifnb_liger_.clusters[i]
  cell1= dat2$a2[i]
  
  for (j in 1:nrow(dat2)){
    clus2 = dat2$ifnb_liger_.clusters[j] 
    cell2 = dat2$a2[j]
    if (cell2 != cell1){
      # check if they belong to the same cluster
      lin = (l[l$X == cell1 ,])$x # this gets the original cluster lable
      ls = (l[l$x==lin, ])$X # get all cells with this cluster label
      if(clus1==clus2){
        # then check if they belong the same true cluster
        if (cell2 %in% ls){
          # then they have the same true cluster
          tp <- tp +1
        }else{
          fp <- fp +1
        }
      }else{
        # the two were not predicted to belong to the same cluster
        # then check if they belong the same true cluster
        if (cell2 %in% ls){
          # then they have the same true cluster
          fn <- fn +1
        }else{
          tn <- tn +1
        }
      }
    }
  }
}
```


```{r}
precision1 <- tp/(tp+fp)
sensitivity1 <- tp/(tp+fn)
(F11 <- 2*(precision1*sensitivity1)/(precision1+sensitivity1)) 
```


